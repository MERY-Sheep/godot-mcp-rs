"""
Godot Query Language (GQL) - Schema (Single Source of Truth)

- This SDL is the canonical contract for GQL.
- `docs/DESIGN_GQL.md` explains the WHY/WHAT and links here for the exact schema.
"""
schema {
  query: Query
  mutation: Mutation
}

"""
Arbitrary JSON value.
Used for flexible operation args and future-proof extension points.
"""
scalar JSON

"""
======================
Query (Read operations)
======================
"""
type Query {
  """
  プロジェクト全体の情報を取得
  """
  project: Project!

  """
  シーンファイルの内容を取得
  """
  scene(path: String!): Scene

  """
  スクリプトファイルの内容を取得
  """
  script(path: String!): Script

  """
  エディター上の現在のシーンを取得（live操作）
  """
  currentScene: LiveScene

  """
  ノードの詳細情報を取得（live操作）
  """
  node(path: String!): LiveNode

  """
  Godotノード型の情報を取得（型メタデータ）
  """
  nodeTypeInfo(typeName: String!): NodeTypeInfo

  """
  エントリーポイントから関連情報を一括収集（index-chan inspired）
  """
  gatherContext(input: GatherContextInput!): GatheredContext!

  """
  プロジェクトの依存関係グラフを取得
  """
  dependencyGraph(input: DependencyGraphInput): DependencyGraph!

  # ========== デバッグ (Phase 2) ==========
  """
  デバッガーのエラー情報を取得
  """
  debuggerErrors: [DebuggerError!]!

  """
  ログを取得
  """
  logs(limit: Int): [LogEntry!]!

  """
  オブジェクトＩＤから詳細情報を取得
  """
  objectById(objectId: String!): GodotObject

  # ========== Phase 3: コード理解 ==========
  """
  スクリプトのクラス階層を取得
  """
  classHierarchy(scriptPath: String!): ClassHierarchy!

  """
  シンボルの参照を検索
  """
  findReferences(symbol: String!, scope: String): SymbolReferences!

  """
  オートロード一覧を取得
  """
  autoloads: AutoloadsResult!

  # ========== Phase 3: デバッグ強化 ==========
  """
  スクリプトの構文エラーを取得（live操作）
  """
  parseErrors(scriptPath: String!): [ParseError!]!

  """
  スタックフレームのローカル変数を取得（デバッグ中）
  """
  stackFrameVars(frameIndex: Int): [StackVariable!]!
}

"""
=========================
Mutation (Write operations)
=========================
"""
type Mutation {
  # ========== ファイルベース操作 ==========
  createScene(input: CreateSceneInput!): SceneResult!
  createSceneFromTemplate(input: TemplateSceneInput!): SceneResult!
  createScript(input: CreateScriptInput!): ScriptResult!

  # ========== ライブ操作（エディター連携） ==========
  addNode(input: AddNodeInput!): NodeResult!
  removeNode(path: String!): OperationResult!
  duplicateNode(path: String!): NodeResult!
  reparentNode(path: String!, newParent: String!): NodeResult!
  setProperty(input: SetPropertyInput!): OperationResult!
  setProperties(
    nodePath: String!
    properties: [PropertyInput!]!
  ): OperationResult!
  connectSignal(input: ConnectSignalInput!): OperationResult!
  disconnectSignal(input: DisconnectSignalInput!): OperationResult!
  addToGroup(nodePath: String!, group: String!): OperationResult!
  removeFromGroup(nodePath: String!, group: String!): OperationResult!
  saveScene: OperationResult!
  openScene(path: String!): OperationResult!

  # ========== 開発・テスト支援 ==========
  """
  GdUnit4テストを実行し、構造化された結果を返却
  """
  runTests(input: RunTestsInput!): TestExecutionResult!

  # ========== Phase 2.2: プロジェクト設定 & 入力マップ ==========
  """
  InputMapにアクションを追加
  """
  addInputAction(input: AddInputActionInput!): OperationResult!

  """
  ProjectSettingsを変更
  """
  setProjectSetting(input: SetProjectSettingInput!): OperationResult!

  # ========== デバッグ制御 (Phase 2) ==========
  """
  実行を一時停止
  """
  pause: OperationResult!

  """
  実行を再開
  """
  resume: OperationResult!

  """
  ステップイン/オーバー実行
  """
  step: OperationResult!

  """
  ブレークポイントを設定
  """
  setBreakpoint(input: BreakpointInput!): OperationResult!

  """
  ブレークポイントを解除
  """
  removeBreakpoint(input: BreakpointInput!): OperationResult!

  # ========== バッチ / 安全な変更フロー ==========

  """
  トランザクションを開始
  - 以降の操作を単一のUndo/Redoアクションにグループ化
  - LLMの1ターンの変更を一括で元に戻せる
  """
  beginTransaction(name: String!): TransactionResult!

  """
  トランザクションをコミット
  - グループ化された操作を確定
  """
  commitTransaction: TransactionResult!

  """
  トランザクションをロールバック
  - トランザクション内の変更を破棄
  """
  rollbackTransaction: TransactionResult!

  """
  変更を事前検証（ドライラン）
  - ノードパスの存在確認
  - プロパティ名の妥当性確認
  - 型の互換性チェック
  """
  validateMutation(input: MutationPlanInput!): MutationValidationResult!

  """
  変更のプレビュー（差分表示）
  - 変更前後の差分をテキストで表示
  - 影響を受けるファイル一覧
  """
  previewMutation(input: MutationPlanInput!): PreviewResult!

  """
  検証済みの変更を適用
  - オプションでバックアップ作成
  - Undo/Redo対応（実装方針）
  """
  applyMutation(input: ApplyMutationInput!): ApplyResult!

  # ========== Phase 3: リファクタリング ==========
  """
  シンボル名を変更（プロジェクト横断）
  """
  renameSymbol(input: RenameSymbolInput!): RenameSymbolResult!

  """
  コードブロックを関数に抽出
  """
  extractFunction(input: ExtractFunctionInput!): ExtractFunctionResult!

  """
  ノードを別シーンに移動
  """
  moveNodeToScene(input: MoveNodeToSceneInput!): MoveNodeToSceneResult!

  # ========== Phase 3: コード生成 ==========
  """
  入力ハンドラーを生成
  """
  generateInputHandler(input: GenerateInputHandlerInput!): CodeGenerationResult!

  """
  ステートマシン雛形を生成
  """
  generateStateMachine(input: GenerateStateMachineInput!): CodeGenerationResult!

  """
  テストスクリプトを生成
  """
  generateTestScript(input: GenerateTestScriptInput!): CodeGenerationResult!

  """
  シェーダーコードを検証 (File-based)
  """
  validateShader(input: ValidateShaderInput!): ShaderValidationResult!

  """
  シェーダーコードを検証 (Live-session)
  """
  validateShaderLive(input: ValidateShaderInput!): ShaderValidationResult!

  """
  ビジュアルシェーダーノードを作成
  """
  createVisualShaderNode(input: CreateVisualShaderNodeInput!): OperationResult!
}

"""
==========
Core Types
==========
"""
type Project {
  name: String!
  path: String!
  scenes: [SceneFile!]!
  scripts: [ScriptFile!]!
  stats: ProjectStats!

  """
  プロジェクト全体の静的検証（ファイル・構文・参照など）
  NOTE: Mutation検証とは別型（名前衝突を避ける）
  """
  validation: ProjectValidationResult!
}

type Scene {
  path: String!
  root: SceneNode!
  allNodes: [SceneNode!]!
  externalResources: [ExternalResource!]!
}

type SceneNode {
  name: String!
  type: String!
  path: String!
  properties: [Property!]!
  property(name: String!): Property
  children: [SceneNode!]!
  script: Script
  groups: [String!]!
  signals: [SignalConnection!]!
}

type LiveScene {
  path: String
  root: LiveNode!
  selectedNodes: [LiveNode!]!
}

type LiveNode {
  name: String!
  type: String!
  path: String!
  globalPosition: Vector3
  globalPosition2D: Vector2
  properties: [Property!]!
  children: [LiveNode!]!
  availableSignals: [SignalInfo!]!
  connectedSignals: [SignalConnection!]!
}

type Script {
  path: String!
  extends: String!
  className: String
  functions: [Function!]!
  variables: [Variable!]!
  signals: [SignalDefinition!]!
  exports: [Variable!]!
}

"""
====================
File & Project Types
====================
"""
type SceneFile {
  path: String!
}

type ScriptFile {
  path: String!
}

type ProjectStats {
  sceneCount: Int!
  scriptCount: Int!
  resourceCount: Int!
}

"""
================
Property / Values
================
NOTE:
- Current design uses `value: String` (GDScript-like textual form).
- In the future, consider a typed VariantInput/VariantValue.
"""
type Property {
  name: String!
  value: String!
  type: String
}

input PropertyInput {
  name: String!
  value: String!
}

"""
=============
Vector helpers
=============
"""
type Vector2 {
  x: Float!
  y: Float!
}

type Vector3 {
  x: Float!
  y: Float!
  z: Float!
}

"""
===============
Signals / Scripts
===============
"""
type Function {
  name: String!
  arguments: [String!]!
}

type Variable {
  name: String!
  type: String!
  defaultValue: String
}

type SignalDefinition {
  name: String!
  arguments: [String!]!
}

type SignalInfo {
  name: String!
  arguments: [String!]!
}

type SignalConnection {
  fromNode: String!
  signal: String!
  toNode: String!
  method: String!
}

type ExternalResource {
  id: Int!
  type: String!
  path: String!
}

"""
======================
Node Type Metadata (WIP)
======================
"""
type NodeTypeInfo {
  typeName: String!
  properties: [NodePropertyInfo!]!
  signals: [SignalInfo!]!
}

type NodePropertyInfo {
  name: String!
  type: String!
  hint: String
}

"""
====================
Mutations: Inputs/Out
====================
"""
input AddNodeInput {
  parent: String!
  name: String!
  type: String!
  properties: [PropertyInput!]
  groups: [String!]
}

input SetPropertyInput {
  nodePath: String!
  property: String!
  """
  値（GDScript形式の文字列）
  """
  value: String!
}

input ConnectSignalInput {
  fromNode: String!
  signal: String!
  toNode: String!
  method: String!
}

type OperationResult {
  success: Boolean!
  message: String
}

type NodeResult {
  success: Boolean!
  node: LiveNode
  message: String
}

type SceneResult {
  success: Boolean!
  scene: Scene
  message: String
}

type ScriptResult {
  success: Boolean!
  script: Script
  message: String
}

"""
File-based inputs (placeholders / WIP)
"""
input CreateSceneInput {
  path: String!
  rootName: String!
  rootType: String!
}

input TemplateSceneInput {
  template: String!
  path: String!
}

input CreateScriptInput {
  path: String!
  extends: String!
  className: String
}

"""
========================================
Safe change flow (validate/preview/apply)
========================================
"""
input MutationPlanInput {
  operations: [PlannedOperation!]!
}

input PlannedOperation {
  type: OperationType!
  args: JSON!
}

enum OperationType {
  ADD_NODE
  REMOVE_NODE
  SET_PROPERTY
  SET_PROPERTIES
  CONNECT_SIGNAL
  DISCONNECT_SIGNAL
  ADD_TO_GROUP
  REMOVE_FROM_GROUP
  REPARENT_NODE
  DUPLICATE_NODE
  CREATE_SCRIPT
  ATTACH_SCRIPT
}

type MutationValidationResult {
  isValid: Boolean!
  errors: [MutationValidationError!]!
  warnings: [MutationValidationWarning!]!
  validationTimeMs: Int!
}

type MutationValidationError {
  operationIndex: Int!
  code: String!
  message: String!
  suggestion: String
}

type MutationValidationWarning {
  operationIndex: Int!
  message: String!
}

type PreviewResult {
  success: Boolean!
  diff: String!
  affectedFiles: [AffectedFile!]!
  summary: ChangeSummary!
}

type AffectedFile {
  path: String!
  changeType: FileChangeType!
}

enum FileChangeType {
  CREATED
  MODIFIED
  DELETED
}

type ChangeSummary {
  nodesAdded: Int!
  nodesRemoved: Int!
  propertiesChanged: Int!
  signalsConnected: Int!
}

input ApplyMutationInput {
  operations: [PlannedOperation!]!
  createBackup: Boolean
  backupDescription: String
}

type ApplyResult {
  success: Boolean!
  appliedCount: Int!
  backupPath: String
  errors: [ApplyError!]!
  undoActionId: String
}

type ApplyError {
  operationIndex: Int!
  message: String!
}

"""
=========================
Project validation (static)
=========================
"""
type ProjectValidationResult {
  isValid: Boolean!
  errors: [ProjectValidationError!]!
  warnings: [ProjectValidationWarning!]!
}

type ProjectValidationError {
  file: String!
  line: Int
  message: String!
  severity: String
}

type ProjectValidationWarning {
  file: String
  message: String!
}

"""
====================
gatherContext (WIP)
====================
"""
input GatherContextInput {
  entryPoint: String!
  depth: Int
  include: [FileType!]
}

enum FileType {
  SCENE
  SCRIPT
  RESOURCE
  SHADER
}

type GatheredContext {
  entryPoint: String!
  main: ContextItem!
  dependencies: [ContextItem!]!
  dependents: [ContextItem!]!
  resources: [ResourceInfo!]!
  summary: ContextSummary!
}

type ContextItem {
  path: String!
  type: FileType!
  scene: Scene
  script: Script
}

type ResourceInfo {
  path: String!
  type: String
}

type ContextSummary {
  totalFiles: Int!
  totalFunctions: Int!
}

"""
========================
dependencyGraph (WIP)
========================
"""
input DependencyGraphInput {
  directory: String
  fileTypes: [FileType!]
  format: GraphFormat
}

enum GraphFormat {
  JSON
  GRAPHML
  DOT
  MERMAID
}

input GraphNodeFilter {
  isUnused: Boolean
}

type DependencyGraph {
  nodes(filter: GraphNodeFilter, limit: Int, offset: Int): [GraphNode!]!
  edges: [GraphEdge!]!
  stats: GraphStats!
  exportedData: String
}

type GraphNode {
  id: String!
  label: String!
  type: FileType!
  inDegree: Int!
  outDegree: Int!
  isUnused: Boolean!
}

type GraphEdge {
  from: String!
  to: String!
  referenceType: ReferenceType!
}

enum ReferenceType {
  INSTANTIATES
  ATTACHES_SCRIPT
  USES_RESOURCE
  PRELOADS
  LOADS
}

type GraphStats {
  nodeCount: Int!
  edgeCount: Int!
  unusedCount: Int!
  hasCycles: Boolean!
  cyclePaths: [[String!]!]
}

"""
========================
runTests Types
========================
"""
input RunTestsInput {
  """
  実行するテストパス (res://tests/ または特定のファイル)
  """
  testPath: String
  """
  リトライ回数
  """
  retries: Int
}

type TestExecutionResult {
  success: Boolean!
  totalCount: Int!
  passedCount: Int!
  failedCount: Int!
  errorCount: Int!
  skippedCount: Int!
  durationMs: Int!
  suites: [TestSuiteResult!]!
}

type TestSuiteResult {
  name: String!
  path: String!
  success: Boolean!
  passedCount: Int!
  failedCount: Int!
  skippedCount: Int!
  cases: [TestCaseResult!]!
}

type TestCaseResult {
  name: String!
  success: Boolean!
  line: Int
  message: String
  stackOverflow: Boolean
}

"""
========================
Phase 2.2: Input Action & Project Settings Types
========================
"""
input AddInputActionInput {
  """
  アクション名 (例: "jump", "move_left")
  """
  actionName: String!
  """
  イベントリスト
  """
  events: [InputEventInput!]!
}

input InputEventInput {
  """
  イベント種別
  """
  type: InputEventType!
  """
  キー名 (KEY の場合)
  """
  key: String
  """
  ボタン番号 (MOUSE_BUTTON / JOY_BUTTON の場合)
  """
  button: Int
  """
  デバイス番号 (ゲームパッド用)
  """
  device: Int
}

enum InputEventType {
  KEY
  MOUSE_BUTTON
  JOY_BUTTON
  JOY_AXIS
}

input SetProjectSettingInput {
  """
  設定パス (例: "application/config/name", "display/window/size/width")
  """
  path: String!
  """
  設定値 (GDScript形式の文字列)
  """
  value: String!
  """
  値の型ヒント (オプション)
  """
  type: String
}

"""
========================
Debugging Types (Phase 2)
========================
"""
type DebuggerError {
  message: String!
  stackInfo: [StackFrame!]!
  timestamp: String
}

type StackFrame {
  file: String!
  line: Int!
  function: String!
}

type LogEntry {
  message: String!
  severity: String!
  timestamp: String!
  file: String
  line: Int
}

type GodotObject {
  id: String!
  class: String!
  properties: [Property!]!
}

input BreakpointInput {
  path: String!
  line: Int!
  enabled: Boolean
}

"""
========================
Phase 3: Debug Enhanced Types
========================
"""
type ParseError {
  line: Int!
  column: Int!
  message: String!
  severity: ErrorSeverity!
}

enum ErrorSeverity {
  ERROR
  WARNING
}

type StackVariable {
  name: String!
  value: String!
  type: String!
}

"""
========================
Phase 3: Code Understanding
========================
"""
type ClassHierarchy {
  scriptPath: String!
  className: String
  extendsChain: [ClassInfo!]!
  depth: Int!
}

type ClassInfo {
  name: String!
  scriptPath: String
  isBuiltin: Boolean!
}

type SymbolReferences {
  symbol: String!
  definition: SymbolLocation
  references: [SymbolLocation!]!
  totalCount: Int!
}

type SymbolLocation {
  file: String!
  line: Int!
  column: Int
  context: String
}

type AutoloadEntry {
  name: String!
  path: String!
  isSingleton: Boolean!
}

type AutoloadsResult {
  autoloads: [AutoloadEntry!]!
  count: Int!
}

"""
========================
Phase 3: Refactoring
========================
"""
input RenameSymbolInput {
  symbol: String!
  newName: String!
  scope: String
}

type RenameSymbolResult {
  success: Boolean!
  oldName: String!
  newName: String!
  filesChanged: [FileChange!]!
  occurrencesReplaced: Int!
  message: String
}

type FileChange {
  path: String!
  changesCount: Int!
}

input ExtractFunctionInput {
  scriptPath: String!
  startLine: Int!
  endLine: Int!
  functionName: String!
  parameters: [String!]
}

type ExtractFunctionResult {
  success: Boolean!
  functionName: String!
  scriptPath: String!
  message: String
}

input MoveNodeToSceneInput {
  nodePath: String!
  newScenePath: String!
  keepInstance: Boolean
}

type MoveNodeToSceneResult {
  success: Boolean!
  newScenePath: String!
  instancePath: String
  message: String
}

"""
========================
Phase 3: Code Generation
========================
"""
input GenerateInputHandlerInput {
  scriptPath: String!
  actions: [String!]!
  handlerType: InputHandlerType
}

enum InputHandlerType {
  PROCESS
  PHYSICS_PROCESS
  UNHANDLED_INPUT
  INPUT
}

input GenerateStateMachineInput {
  scriptPath: String!
  states: [String!]!
  initialState: String
  useEnum: Boolean
}

input GenerateTestScriptInput {
  targetScript: String!
  outputPath: String
  testFramework: TestFramework
}

enum TestFramework {
  GDUNIT4
  GUT
  CUSTOM
}

type CodeGenerationResult {
  success: Boolean!
  path: String!
  message: String
}

"""
========================
Phase 3: Shader Support
========================
"""
input ValidateShaderInput {
  shaderCode: String!
  shaderType: ShaderType
}

enum ShaderType {
  SPATIAL
  CANVAS_ITEM
  PARTICLES
  SKY
  FOG
}

type ShaderValidationResult {
  isValid: Boolean!
  errors: [ShaderError!]!
  warnings: [ShaderWarning!]!
}

type ShaderError {
  line: Int
  column: Int
  message: String!
}

type ShaderWarning {
  line: Int
  message: String!
}

input CreateVisualShaderNodeInput {
  shaderPath: String!
  nodeType: String!
  positionX: Float
  positionY: Float
}
